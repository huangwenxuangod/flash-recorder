name: Release Windows

on:
  push:
    branches:
      - main
    tags:
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag (e.g. v0.1.0)"
        required: true
        type: string
      name:
        description: "Release title (defaults to tag)"
        required: false
        type: string
      prerelease:
        description: "Mark as prerelease"
        required: false
        type: boolean

permissions:
  contents: write

jobs:
  build-windows:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install pnpm globally
        run: npm install -g pnpm@9

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9
          run_install: false

      - name: Verify pnpm
        run: pnpm -v

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: "pnpm"

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Prepare ffmpeg for bundling
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force "src-tauri/ffmpeg" | Out-Null
          $zipUrl = "https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip"
          Invoke-WebRequest -Uri $zipUrl -OutFile "ffmpeg.zip"
          Expand-Archive -Path "ffmpeg.zip" -DestinationPath "ffmpeg_zip" -Force
          $ff = Get-ChildItem -Path "ffmpeg_zip" -Recurse -Filter "ffmpeg.exe" | Select-Object -First 1
          Copy-Item $ff.FullName "src-tauri/ffmpeg/ffmpeg.exe" -Force

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build Tauri (Windows)
        run: pnpm run tauri build

      - name: Create self-signed certificate (Code Signing)
        if: ${{ startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch' }}
        shell: pwsh
        timeout-minutes: 3
        run: |
          $subject = "CN=Flash Recorder SelfSign"
          $cert = New-SelfSignedCertificate -Type CodeSigning -Subject $subject -KeyExportPolicy Exportable -KeyLength 2048 -HashAlgorithm sha256 -KeyAlgorithm RSA -NotAfter (Get-Date).AddYears(3) -CertStoreLocation Cert:\CurrentUser\My
          $pass = [guid]::NewGuid().ToString()
          $secure = ConvertTo-SecureString -String $pass -Force -AsPlainText
          $pfxPath = Join-Path -Path $env:GITHUB_WORKSPACE -ChildPath "cert.pfx"
          $cerPath = Join-Path -Path $env:GITHUB_WORKSPACE -ChildPath "cert.cer"
          Export-PfxCertificate -Cert $cert -FilePath $pfxPath -Password $secure
          Export-Certificate -Cert $cert -FilePath $cerPath -ErrorAction Stop
          Import-Certificate -FilePath $cerPath -CertStoreLocation Cert:\CurrentUser\Root -ErrorAction Stop
          Import-Certificate -FilePath $cerPath -CertStoreLocation Cert:\CurrentUser\TrustedPublisher -ErrorAction Stop
          $rootCert = Get-ChildItem Cert:\CurrentUser\Root | Where-Object { $_.Thumbprint -eq $cert.Thumbprint }
          $trustedCert = Get-ChildItem Cert:\CurrentUser\TrustedPublisher | Where-Object { $_.Thumbprint -eq $cert.Thumbprint }
          if (-not $rootCert) { throw "Root import failed" }
          if (-not $trustedCert) { throw "TrustedPublisher import failed" }
          Add-Content -Path $env:GITHUB_ENV -Value ("PFX_FILE=" + $pfxPath)
          Add-Content -Path $env:GITHUB_ENV -Value ("PFX_PASSWORD=" + $pass)

      - name: Locate signtool.exe
        shell: pwsh
        run: |
          $tool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter "signtool.exe" | Where-Object { $_.FullName -match "\\x64\\signtool\.exe$" } | Select-Object -First 1
          if ($null -eq $tool) { throw "signtool.exe not found" }
          Add-Content -Path $env:GITHUB_ENV -Value ("SIGNTOOL=" + $tool.FullName)

      - name: Sign MSI and NSIS installers (self-signed)
        if: ${{ startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch' }}
        shell: pwsh
        run: |
          $bundle = "src-tauri/target/release/bundle"
          $files = @()
          $files += Get-ChildItem "$bundle/msi/*.msi" -ErrorAction SilentlyContinue
          $files += Get-ChildItem "$bundle/nsis/*.exe" -ErrorAction SilentlyContinue
          if ($files.Count -eq 0) { throw "No installer files found to sign." }
          if ([string]::IsNullOrWhiteSpace($env:PFX_FILE) -or [string]::IsNullOrWhiteSpace($env:PFX_PASSWORD)) { throw "Missing PFX_FILE or PFX_PASSWORD" }
          if ([string]::IsNullOrWhiteSpace($env:SIGNTOOL)) { throw "SIGNTOOL not set" }
          Write-Host ("SIGNTOOL: " + $env:SIGNTOOL)
          Write-Host ("PFX_FILE: " + $env:PFX_FILE)
          foreach ($f in $files) {
            & $env:SIGNTOOL sign /f "$env:PFX_FILE" /p "$env:PFX_PASSWORD" /fd sha256 "$($f.FullName)"
            if ($LASTEXITCODE -ne 0) { throw ("Sign failed: " + $f.FullName) }
            try {
              & $env:SIGNTOOL timestamp /tr "http://timestamp.digicert.com" /td sha256 "$($f.FullName)"
              if ($LASTEXITCODE -ne 0) { Write-Host ("Timestamp failed: " + $f.FullName) }
            } catch {
              Write-Host ("Timestamp exception: " + $f.FullName)
            }
          }

      - name: Verify signatures
        shell: pwsh
        run: |
          $bundle = "src-tauri/target/release/bundle"
          Get-ChildItem "$bundle/msi/*.msi","$bundle/nsis/*.exe" -ErrorAction SilentlyContinue | ForEach-Object {
            & $env:SIGNTOOL verify /pa $_.FullName
          }

      - name: Set release metadata
        if: ${{ startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch' }}
        shell: pwsh
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $tag = "${{ inputs.tag }}"
            $name = "${{ inputs.name }}"
            if ([string]::IsNullOrWhiteSpace($name)) { $name = $tag }
          } else {
            $tag = "${{ github.ref_name }}"
            $name = $tag
          }
          Add-Content -Path $env:GITHUB_ENV -Value "RELEASE_TAG=$tag"
          Add-Content -Path $env:GITHUB_ENV -Value "RELEASE_NAME=$name"

      - name: Generate checksums
        shell: pwsh
        run: |
          $bundle = "src-tauri/target/release/bundle"
          Get-ChildItem "$bundle/msi/*.msi","$bundle/nsis/*.exe" -ErrorAction SilentlyContinue | ForEach-Object {
            $hash = Get-FileHash $_.FullName -Algorithm SHA256
            $hashLine = "$($hash.Hash)  $($_.Name)"
            $outFile = "$($_.FullName).sha256"
            $hashLine | Out-File -FilePath $outFile -Encoding ascii
          }

      - name: Upload Release Assets
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: ${{ env.RELEASE_NAME }}
          prerelease: ${{ inputs.prerelease }}
          generate_release_notes: true
          files: |
            src-tauri/target/release/bundle/msi/*.msi
            src-tauri/target/release/bundle/msi/*.sha256
            src-tauri/target/release/bundle/nsis/*.exe
            src-tauri/target/release/bundle/nsis/*.sha256
