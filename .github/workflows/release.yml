name: Release Windows

on:
  push:
    tags:
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag (e.g. v0.1.0)"
        required: true
        type: string
      name:
        description: "Release title (defaults to tag)"
        required: false
        type: string
      prerelease:
        description: "Mark as prerelease"
        required: false
        type: boolean

permissions:
  contents: write

jobs:
  build-windows:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: "pnpm"

      - name: Install pnpm globally
        run: npm install -g pnpm@8

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 8
          run_install: false

      - name: Verify pnpm
        run: pnpm -v

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Prepare ffmpeg for bundling
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force "src-tauri/ffmpeg" | Out-Null
          $zipUrl = "https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip"
          Invoke-WebRequest -Uri $zipUrl -OutFile "ffmpeg.zip"
          Expand-Archive -Path "ffmpeg.zip" -DestinationPath "ffmpeg_zip" -Force
          $ff = Get-ChildItem -Path "ffmpeg_zip" -Recurse -Filter "ffmpeg.exe" | Select-Object -First 1
          Copy-Item $ff.FullName "src-tauri/ffmpeg/ffmpeg.exe" -Force

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build Tauri (Windows)
        run: pnpm run tauri build

      - name: Create self-signed certificate (Code Signing)
        shell: pwsh
        run: |
          $subject = "CN=Flash Recorder SelfSign"
          $cert = New-SelfSignedCertificate -Type CodeSigning -Subject $subject -KeyExportPolicy Exportable -KeyLength 2048 -HashAlgorithm sha256 -CertStoreLocation Cert:\CurrentUser\My
          $pass = [guid]::NewGuid().ToString()
          $secure = ConvertTo-SecureString -String $pass -Force -AsPlainText
          Export-PfxCertificate -Cert $cert -FilePath "cert.pfx" -Password $secure | Out-Null
          Add-Content -Path $env:GITHUB_ENV -Value "PFX_FILE=cert.pfx"
          Add-Content -Path $env:GITHUB_ENV -Value "PFX_PASSWORD=$pass"

      - name: Locate signtool.exe
        shell: pwsh
        run: |
          $tool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter "signtool.exe" | Where-Object { $_.FullName -match "\\x64\\signtool\.exe$" } | Select-Object -First 1
          if ($null -eq $tool) { throw "signtool.exe not found" }
          Add-Content -Path $env:GITHUB_ENV -Value ("SIGNTOOL=" + $tool.FullName)

      - name: Sign MSI and NSIS installers (self-signed)
        shell: pwsh
        run: |
          $bundle = "src-tauri/target/release/bundle"
          $files = @()
          $files += Get-ChildItem "$bundle/msi/*.msi" -ErrorAction SilentlyContinue
          $files += Get-ChildItem "$bundle/nsis/*.exe" -ErrorAction SilentlyContinue
          if ($files.Count -eq 0) { throw "No installer files found to sign." }
          $tsUrl = "http://timestamp.digicert.com"
          foreach ($f in $files) {
            try {
              & $env:SIGNTOOL sign /f $env:PFX_FILE /p $env:PFX_PASSWORD /tr $tsUrl /td sha256 $f.FullName
            } catch {
              & $env:SIGNTOOL sign /f $env:PFX_FILE /p $env:PFX_PASSWORD /t $tsUrl $f.FullName
            }
          }

      - name: Verify signatures
        shell: pwsh
        run: |
          $bundle = "src-tauri/target/release/bundle"
          Get-ChildItem "$bundle/msi/*.msi","$bundle/nsis/*.exe" -ErrorAction SilentlyContinue | ForEach-Object {
            & $env:SIGNTOOL verify /pa $_.FullName
          }

      - name: Set release metadata
        if: ${{ startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch' }}
        shell: pwsh
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $tag = "${{ inputs.tag }}"
            $name = "${{ inputs.name }}"
            if ([string]::IsNullOrWhiteSpace($name)) { $name = $tag }
          } else {
            $tag = "${{ github.ref_name }}"
            $name = $tag
          }
          Add-Content -Path $env:GITHUB_ENV -Value "RELEASE_TAG=$tag"
          Add-Content -Path $env:GITHUB_ENV -Value "RELEASE_NAME=$name"

      - name: Generate checksums
        shell: pwsh
        run: |
          $bundle = "src-tauri/target/release/bundle"
          Get-ChildItem "$bundle/msi/*.msi","$bundle/nsis/*.exe" -ErrorAction SilentlyContinue | ForEach-Object {
            $hash = Get-FileHash $_.FullName -Algorithm SHA256
            $hashLine = "$($hash.Hash)  $($_.Name)"
            $outFile = "$($_.FullName).sha256"
            $hashLine | Out-File -FilePath $outFile -Encoding ascii
          }

      - name: Upload Release Assets
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: ${{ env.RELEASE_NAME }}
          prerelease: ${{ inputs.prerelease }}
          generate_release_notes: true
          files: |
            src-tauri/target/release/bundle/msi/*.msi
            src-tauri/target/release/bundle/msi/*.sha256
            src-tauri/target/release/bundle/nsis/*.exe
            src-tauri/target/release/bundle/nsis/*.sha256
